// automatically generated by the FlatBuffers compiler, do not modify
// @generated
extern crate alloc;


#[allow(unused_imports, dead_code)]
pub mod gallery {

#[allow(unused_imports, dead_code)]
pub mod schema {


pub enum FileOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct File<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for File<'a> {
  type Inner = File<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> File<'a> {
  pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
  pub const VT_HASH: ::flatbuffers::VOffsetT = 6;
  pub const VT_WIDTH: ::flatbuffers::VOffsetT = 8;
  pub const VT_HEIGHT: ::flatbuffers::VOffsetT = 10;
  pub const VT_HASAVIF: ::flatbuffers::VOffsetT = 12;
  pub const VT_HASWEBP: ::flatbuffers::VOffsetT = 14;
  pub const VT_HASJXL: ::flatbuffers::VOffsetT = 16;
  pub const VT_SINGLE: ::flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    File { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args FileArgs<'args>
  ) -> ::flatbuffers::WIPOffset<File<'bldr>> {
    let mut builder = FileBuilder::new(_fbb);
    builder.add_height(args.height);
    builder.add_width(args.width);
    if let Some(x) = args.hash { builder.add_hash(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.add_single(args.single);
    builder.add_hasjxl(args.hasjxl);
    builder.add_haswebp(args.haswebp);
    builder.add_hasavif(args.hasavif);
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(File::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn hash(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(File::VT_HASH, None).unwrap()}
  }
  #[inline]
  pub fn width(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(File::VT_WIDTH, Some(0)).unwrap()}
  }
  #[inline]
  pub fn height(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(File::VT_HEIGHT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn hasavif(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(File::VT_HASAVIF, Some(false)).unwrap()}
  }
  #[inline]
  pub fn haswebp(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(File::VT_HASWEBP, Some(false)).unwrap()}
  }
  #[inline]
  pub fn hasjxl(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(File::VT_HASJXL, Some(false)).unwrap()}
  }
  #[inline]
  pub fn single(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(File::VT_SINGLE, Some(false)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for File<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("hash", Self::VT_HASH, true)?
     .visit_field::<i32>("width", Self::VT_WIDTH, false)?
     .visit_field::<i32>("height", Self::VT_HEIGHT, false)?
     .visit_field::<bool>("hasavif", Self::VT_HASAVIF, false)?
     .visit_field::<bool>("haswebp", Self::VT_HASWEBP, false)?
     .visit_field::<bool>("hasjxl", Self::VT_HASJXL, false)?
     .visit_field::<bool>("single", Self::VT_SINGLE, false)?
     .finish();
    Ok(())
  }
}
pub struct FileArgs<'a> {
    pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub hash: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub width: i32,
    pub height: i32,
    pub hasavif: bool,
    pub haswebp: bool,
    pub hasjxl: bool,
    pub single: bool,
}
impl<'a> Default for FileArgs<'a> {
  #[inline]
  fn default() -> Self {
    FileArgs {
      name: None, // required field
      hash: None, // required field
      width: 0,
      height: 0,
      hasavif: false,
      haswebp: false,
      hasjxl: false,
      single: false,
    }
  }
}

pub struct FileBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> FileBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(File::VT_NAME, name);
  }
  #[inline]
  pub fn add_hash(&mut self, hash: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(File::VT_HASH, hash);
  }
  #[inline]
  pub fn add_width(&mut self, width: i32) {
    self.fbb_.push_slot::<i32>(File::VT_WIDTH, width, 0);
  }
  #[inline]
  pub fn add_height(&mut self, height: i32) {
    self.fbb_.push_slot::<i32>(File::VT_HEIGHT, height, 0);
  }
  #[inline]
  pub fn add_hasavif(&mut self, hasavif: bool) {
    self.fbb_.push_slot::<bool>(File::VT_HASAVIF, hasavif, false);
  }
  #[inline]
  pub fn add_haswebp(&mut self, haswebp: bool) {
    self.fbb_.push_slot::<bool>(File::VT_HASWEBP, haswebp, false);
  }
  #[inline]
  pub fn add_hasjxl(&mut self, hasjxl: bool) {
    self.fbb_.push_slot::<bool>(File::VT_HASJXL, hasjxl, false);
  }
  #[inline]
  pub fn add_single(&mut self, single: bool) {
    self.fbb_.push_slot::<bool>(File::VT_SINGLE, single, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> FileBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    FileBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<File<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, File::VT_NAME,"name");
    self.fbb_.required(o, File::VT_HASH,"hash");
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for File<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("File");
      ds.field("name", &self.name());
      ds.field("hash", &self.hash());
      ds.field("width", &self.width());
      ds.field("height", &self.height());
      ds.field("hasavif", &self.hasavif());
      ds.field("haswebp", &self.haswebp());
      ds.field("hasjxl", &self.hasjxl());
      ds.field("single", &self.single());
      ds.finish()
  }
}
pub enum LanguageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Language<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Language<'a> {
  type Inner = Language<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Language<'a> {
  pub const VT_NAME: ::flatbuffers::VOffsetT = 4;
  pub const VT_LANGUAGE_LOCALNAME: ::flatbuffers::VOffsetT = 6;
  pub const VT_URL: ::flatbuffers::VOffsetT = 8;
  pub const VT_GALLERYID: ::flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Language { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args LanguageArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Language<'bldr>> {
    let mut builder = LanguageBuilder::new(_fbb);
    if let Some(x) = args.galleryid { builder.add_galleryid(x); }
    if let Some(x) = args.url { builder.add_url(x); }
    if let Some(x) = args.language_localname { builder.add_language_localname(x); }
    if let Some(x) = args.name { builder.add_name(x); }
    builder.finish()
  }


  #[inline]
  pub fn name(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Language::VT_NAME, None).unwrap()}
  }
  #[inline]
  pub fn language_localname(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Language::VT_LANGUAGE_LOCALNAME, None).unwrap()}
  }
  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Language::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn galleryid(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Language::VT_GALLERYID, None).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Language<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("name", Self::VT_NAME, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("language_localname", Self::VT_LANGUAGE_LOCALNAME, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("galleryid", Self::VT_GALLERYID, true)?
     .finish();
    Ok(())
  }
}
pub struct LanguageArgs<'a> {
    pub name: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub language_localname: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub galleryid: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for LanguageArgs<'a> {
  #[inline]
  fn default() -> Self {
    LanguageArgs {
      name: None, // required field
      language_localname: None, // required field
      url: None, // required field
      galleryid: None, // required field
    }
  }
}

pub struct LanguageBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> LanguageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_name(&mut self, name: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Language::VT_NAME, name);
  }
  #[inline]
  pub fn add_language_localname(&mut self, language_localname: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Language::VT_LANGUAGE_LOCALNAME, language_localname);
  }
  #[inline]
  pub fn add_url(&mut self, url: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Language::VT_URL, url);
  }
  #[inline]
  pub fn add_galleryid(&mut self, galleryid: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Language::VT_GALLERYID, galleryid);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> LanguageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    LanguageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Language<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Language::VT_NAME,"name");
    self.fbb_.required(o, Language::VT_LANGUAGE_LOCALNAME,"language_localname");
    self.fbb_.required(o, Language::VT_URL,"url");
    self.fbb_.required(o, Language::VT_GALLERYID,"galleryid");
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Language<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Language");
      ds.field("name", &self.name());
      ds.field("language_localname", &self.language_localname());
      ds.field("url", &self.url());
      ds.field("galleryid", &self.galleryid());
      ds.finish()
  }
}
pub enum ArtistOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Artist<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Artist<'a> {
  type Inner = Artist<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Artist<'a> {
  pub const VT_ARTIST: ::flatbuffers::VOffsetT = 4;
  pub const VT_URL: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Artist { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ArtistArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Artist<'bldr>> {
    let mut builder = ArtistBuilder::new(_fbb);
    if let Some(x) = args.url { builder.add_url(x); }
    if let Some(x) = args.artist { builder.add_artist(x); }
    builder.finish()
  }


  #[inline]
  pub fn artist(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Artist::VT_ARTIST, None).unwrap()}
  }
  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Artist::VT_URL, None).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Artist<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("artist", Self::VT_ARTIST, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .finish();
    Ok(())
  }
}
pub struct ArtistArgs<'a> {
    pub artist: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ArtistArgs<'a> {
  #[inline]
  fn default() -> Self {
    ArtistArgs {
      artist: None, // required field
      url: None, // required field
    }
  }
}

pub struct ArtistBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ArtistBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_artist(&mut self, artist: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Artist::VT_ARTIST, artist);
  }
  #[inline]
  pub fn add_url(&mut self, url: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Artist::VT_URL, url);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ArtistBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ArtistBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Artist<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Artist::VT_ARTIST,"artist");
    self.fbb_.required(o, Artist::VT_URL,"url");
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Artist<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Artist");
      ds.field("artist", &self.artist());
      ds.field("url", &self.url());
      ds.finish()
  }
}
pub enum GroupOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Group<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Group<'a> {
  type Inner = Group<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Group<'a> {
  pub const VT_GROUP: ::flatbuffers::VOffsetT = 4;
  pub const VT_URL: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Group { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GroupArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Group<'bldr>> {
    let mut builder = GroupBuilder::new(_fbb);
    if let Some(x) = args.url { builder.add_url(x); }
    if let Some(x) = args.group { builder.add_group(x); }
    builder.finish()
  }


  #[inline]
  pub fn group(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Group::VT_GROUP, None).unwrap()}
  }
  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Group::VT_URL, None).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Group<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("group", Self::VT_GROUP, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .finish();
    Ok(())
  }
}
pub struct GroupArgs<'a> {
    pub group: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for GroupArgs<'a> {
  #[inline]
  fn default() -> Self {
    GroupArgs {
      group: None, // required field
      url: None, // required field
    }
  }
}

pub struct GroupBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> GroupBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_group(&mut self, group: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Group::VT_GROUP, group);
  }
  #[inline]
  pub fn add_url(&mut self, url: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Group::VT_URL, url);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> GroupBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GroupBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Group<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Group::VT_GROUP,"group");
    self.fbb_.required(o, Group::VT_URL,"url");
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Group<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Group");
      ds.field("group", &self.group());
      ds.field("url", &self.url());
      ds.finish()
  }
}
pub enum CharacterOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Character<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Character<'a> {
  type Inner = Character<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Character<'a> {
  pub const VT_CHARACTER: ::flatbuffers::VOffsetT = 4;
  pub const VT_URL: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Character { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args CharacterArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Character<'bldr>> {
    let mut builder = CharacterBuilder::new(_fbb);
    if let Some(x) = args.url { builder.add_url(x); }
    if let Some(x) = args.character { builder.add_character(x); }
    builder.finish()
  }


  #[inline]
  pub fn character(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Character::VT_CHARACTER, None).unwrap()}
  }
  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Character::VT_URL, None).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Character<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("character", Self::VT_CHARACTER, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .finish();
    Ok(())
  }
}
pub struct CharacterArgs<'a> {
    pub character: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for CharacterArgs<'a> {
  #[inline]
  fn default() -> Self {
    CharacterArgs {
      character: None, // required field
      url: None, // required field
    }
  }
}

pub struct CharacterBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> CharacterBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_character(&mut self, character: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Character::VT_CHARACTER, character);
  }
  #[inline]
  pub fn add_url(&mut self, url: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Character::VT_URL, url);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> CharacterBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    CharacterBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Character<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Character::VT_CHARACTER,"character");
    self.fbb_.required(o, Character::VT_URL,"url");
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Character<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Character");
      ds.field("character", &self.character());
      ds.field("url", &self.url());
      ds.finish()
  }
}
pub enum ParodyOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Parody<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Parody<'a> {
  type Inner = Parody<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Parody<'a> {
  pub const VT_PARODY: ::flatbuffers::VOffsetT = 4;
  pub const VT_URL: ::flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Parody { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ParodyArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Parody<'bldr>> {
    let mut builder = ParodyBuilder::new(_fbb);
    if let Some(x) = args.url { builder.add_url(x); }
    if let Some(x) = args.parody { builder.add_parody(x); }
    builder.finish()
  }


  #[inline]
  pub fn parody(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Parody::VT_PARODY, None).unwrap()}
  }
  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Parody::VT_URL, None).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Parody<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("parody", Self::VT_PARODY, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .finish();
    Ok(())
  }
}
pub struct ParodyArgs<'a> {
    pub parody: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<::flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for ParodyArgs<'a> {
  #[inline]
  fn default() -> Self {
    ParodyArgs {
      parody: None, // required field
      url: None, // required field
    }
  }
}

pub struct ParodyBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> ParodyBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_parody(&mut self, parody: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Parody::VT_PARODY, parody);
  }
  #[inline]
  pub fn add_url(&mut self, url: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Parody::VT_URL, url);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> ParodyBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ParodyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Parody<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Parody::VT_PARODY,"parody");
    self.fbb_.required(o, Parody::VT_URL,"url");
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Parody<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Parody");
      ds.field("parody", &self.parody());
      ds.field("url", &self.url());
      ds.finish()
  }
}
pub enum TagOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Tag<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Tag<'a> {
  type Inner = Tag<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Tag<'a> {
  pub const VT_TAG: ::flatbuffers::VOffsetT = 4;
  pub const VT_URL: ::flatbuffers::VOffsetT = 6;
  pub const VT_MALE: ::flatbuffers::VOffsetT = 8;
  pub const VT_FEMALE: ::flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Tag { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args TagArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Tag<'bldr>> {
    let mut builder = TagBuilder::new(_fbb);
    if let Some(x) = args.url { builder.add_url(x); }
    if let Some(x) = args.tag { builder.add_tag(x); }
    builder.add_female(args.female);
    builder.add_male(args.male);
    builder.finish()
  }


  #[inline]
  pub fn tag(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Tag::VT_TAG, None).unwrap()}
  }
  #[inline]
  pub fn url(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Tag::VT_URL, None).unwrap()}
  }
  #[inline]
  pub fn male(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Tag::VT_MALE, Some(false)).unwrap()}
  }
  #[inline]
  pub fn female(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Tag::VT_FEMALE, Some(false)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Tag<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("tag", Self::VT_TAG, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("url", Self::VT_URL, true)?
     .visit_field::<bool>("male", Self::VT_MALE, false)?
     .visit_field::<bool>("female", Self::VT_FEMALE, false)?
     .finish();
    Ok(())
  }
}
pub struct TagArgs<'a> {
    pub tag: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub url: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub male: bool,
    pub female: bool,
}
impl<'a> Default for TagArgs<'a> {
  #[inline]
  fn default() -> Self {
    TagArgs {
      tag: None, // required field
      url: None, // required field
      male: false,
      female: false,
    }
  }
}

pub struct TagBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> TagBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_tag(&mut self, tag: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Tag::VT_TAG, tag);
  }
  #[inline]
  pub fn add_url(&mut self, url: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Tag::VT_URL, url);
  }
  #[inline]
  pub fn add_male(&mut self, male: bool) {
    self.fbb_.push_slot::<bool>(Tag::VT_MALE, male, false);
  }
  #[inline]
  pub fn add_female(&mut self, female: bool) {
    self.fbb_.push_slot::<bool>(Tag::VT_FEMALE, female, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> TagBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    TagBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Tag<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Tag::VT_TAG,"tag");
    self.fbb_.required(o, Tag::VT_URL,"url");
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Tag<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Tag");
      ds.field("tag", &self.tag());
      ds.field("url", &self.url());
      ds.field("male", &self.male());
      ds.field("female", &self.female());
      ds.finish()
  }
}
pub enum GalleryOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Gallery<'a> {
  pub _tab: ::flatbuffers::Table<'a>,
}

impl<'a> ::flatbuffers::Follow<'a> for Gallery<'a> {
  type Inner = Gallery<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { ::flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Gallery<'a> {
  pub const VT_GALLERY_ID: ::flatbuffers::VOffsetT = 4;
  pub const VT_TITLE: ::flatbuffers::VOffsetT = 6;
  pub const VT_DATE: ::flatbuffers::VOffsetT = 8;
  pub const VT_FILES: ::flatbuffers::VOffsetT = 10;
  pub const VT_LANGUAGES: ::flatbuffers::VOffsetT = 12;
  pub const VT_SCENE_INDEXES: ::flatbuffers::VOffsetT = 14;
  pub const VT_TYPE_: ::flatbuffers::VOffsetT = 16;
  pub const VT_ID: ::flatbuffers::VOffsetT = 18;
  pub const VT_RELATED: ::flatbuffers::VOffsetT = 20;
  pub const VT_JAPANESE_TITLE: ::flatbuffers::VOffsetT = 22;
  pub const VT_LANGUAGE: ::flatbuffers::VOffsetT = 24;
  pub const VT_LANGUAGE_LOCALNAME: ::flatbuffers::VOffsetT = 26;
  pub const VT_LANGUAGE_URL: ::flatbuffers::VOffsetT = 28;
  pub const VT_VIDEO: ::flatbuffers::VOffsetT = 30;
  pub const VT_VIDEOFILENAME: ::flatbuffers::VOffsetT = 32;
  pub const VT_ARTISTS: ::flatbuffers::VOffsetT = 34;
  pub const VT_GROUPS: ::flatbuffers::VOffsetT = 36;
  pub const VT_CHARACTERS: ::flatbuffers::VOffsetT = 38;
  pub const VT_PARODIES: ::flatbuffers::VOffsetT = 40;
  pub const VT_TAGS: ::flatbuffers::VOffsetT = 42;
  pub const VT_GALLERY_URL: ::flatbuffers::VOffsetT = 44;
  pub const VT_DATE_PUBLISHED: ::flatbuffers::VOffsetT = 46;
  pub const VT_BLOCKED: ::flatbuffers::VOffsetT = 48;

  #[inline]
  pub unsafe fn init_from_table(table: ::flatbuffers::Table<'a>) -> Self {
    Gallery { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: ::flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut ::flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args GalleryArgs<'args>
  ) -> ::flatbuffers::WIPOffset<Gallery<'bldr>> {
    let mut builder = GalleryBuilder::new(_fbb);
    if let Some(x) = args.date_published { builder.add_date_published(x); }
    if let Some(x) = args.gallery_url { builder.add_gallery_url(x); }
    if let Some(x) = args.tags { builder.add_tags(x); }
    if let Some(x) = args.parodies { builder.add_parodies(x); }
    if let Some(x) = args.characters { builder.add_characters(x); }
    if let Some(x) = args.groups { builder.add_groups(x); }
    if let Some(x) = args.artists { builder.add_artists(x); }
    if let Some(x) = args.videofilename { builder.add_videofilename(x); }
    if let Some(x) = args.video { builder.add_video(x); }
    if let Some(x) = args.language_url { builder.add_language_url(x); }
    if let Some(x) = args.language_localname { builder.add_language_localname(x); }
    if let Some(x) = args.language { builder.add_language(x); }
    if let Some(x) = args.japanese_title { builder.add_japanese_title(x); }
    if let Some(x) = args.related { builder.add_related(x); }
    if let Some(x) = args.id { builder.add_id(x); }
    if let Some(x) = args.type_ { builder.add_type_(x); }
    if let Some(x) = args.scene_indexes { builder.add_scene_indexes(x); }
    if let Some(x) = args.languages { builder.add_languages(x); }
    if let Some(x) = args.files { builder.add_files(x); }
    if let Some(x) = args.date { builder.add_date(x); }
    if let Some(x) = args.title { builder.add_title(x); }
    builder.add_gallery_id(args.gallery_id);
    builder.add_blocked(args.blocked);
    builder.finish()
  }


  #[inline]
  pub fn gallery_id(&self) -> i32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<i32>(Gallery::VT_GALLERY_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn title(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_TITLE, None).unwrap()}
  }
  #[inline]
  pub fn date(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_DATE, None).unwrap()}
  }
  #[inline]
  pub fn files(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<File<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<File>>>>(Gallery::VT_FILES, None)}
  }
  #[inline]
  pub fn languages(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Language<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Language>>>>(Gallery::VT_LANGUAGES, None)}
  }
  #[inline]
  pub fn scene_indexes(&self) -> Option<::flatbuffers::Vector<'a, i32>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, i32>>>(Gallery::VT_SCENE_INDEXES, None)}
  }
  #[inline]
  pub fn type_(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_TYPE_, None).unwrap()}
  }
  #[inline]
  pub fn id(&self) -> &'a str {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_ID, None).unwrap()}
  }
  #[inline]
  pub fn related(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>>>(Gallery::VT_RELATED, None)}
  }
  #[inline]
  pub fn japanese_title(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_JAPANESE_TITLE, None)}
  }
  #[inline]
  pub fn language(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_LANGUAGE, None)}
  }
  #[inline]
  pub fn language_localname(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_LANGUAGE_LOCALNAME, None)}
  }
  #[inline]
  pub fn language_url(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_LANGUAGE_URL, None)}
  }
  #[inline]
  pub fn video(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_VIDEO, None)}
  }
  #[inline]
  pub fn videofilename(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_VIDEOFILENAME, None)}
  }
  #[inline]
  pub fn artists(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Artist<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Artist>>>>(Gallery::VT_ARTISTS, None)}
  }
  #[inline]
  pub fn groups(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Group<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Group>>>>(Gallery::VT_GROUPS, None)}
  }
  #[inline]
  pub fn characters(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Character<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Character>>>>(Gallery::VT_CHARACTERS, None)}
  }
  #[inline]
  pub fn parodies(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Parody<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Parody>>>>(Gallery::VT_PARODIES, None)}
  }
  #[inline]
  pub fn tags(&self) -> Option<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Tag<'a>>>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Tag>>>>(Gallery::VT_TAGS, None)}
  }
  #[inline]
  pub fn gallery_url(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_GALLERY_URL, None)}
  }
  #[inline]
  pub fn date_published(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<::flatbuffers::ForwardsUOffset<&str>>(Gallery::VT_DATE_PUBLISHED, None)}
  }
  #[inline]
  pub fn blocked(&self) -> bool {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<bool>(Gallery::VT_BLOCKED, Some(false)).unwrap()}
  }
}

impl ::flatbuffers::Verifiable for Gallery<'_> {
  #[inline]
  fn run_verifier(
    v: &mut ::flatbuffers::Verifier, pos: usize
  ) -> Result<(), ::flatbuffers::InvalidFlatbuffer> {
    v.visit_table(pos)?
     .visit_field::<i32>("gallery_id", Self::VT_GALLERY_ID, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("title", Self::VT_TITLE, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("date", Self::VT_DATE, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<File>>>>("files", Self::VT_FILES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Language>>>>("languages", Self::VT_LANGUAGES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, i32>>>("scene_indexes", Self::VT_SCENE_INDEXES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("type_", Self::VT_TYPE_, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("id", Self::VT_ID, true)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<&'_ str>>>>("related", Self::VT_RELATED, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("japanese_title", Self::VT_JAPANESE_TITLE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("language", Self::VT_LANGUAGE, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("language_localname", Self::VT_LANGUAGE_LOCALNAME, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("language_url", Self::VT_LANGUAGE_URL, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("video", Self::VT_VIDEO, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("videofilename", Self::VT_VIDEOFILENAME, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Artist>>>>("artists", Self::VT_ARTISTS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Group>>>>("groups", Self::VT_GROUPS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Character>>>>("characters", Self::VT_CHARACTERS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Parody>>>>("parodies", Self::VT_PARODIES, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<::flatbuffers::Vector<'_, ::flatbuffers::ForwardsUOffset<Tag>>>>("tags", Self::VT_TAGS, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("gallery_url", Self::VT_GALLERY_URL, false)?
     .visit_field::<::flatbuffers::ForwardsUOffset<&str>>("date_published", Self::VT_DATE_PUBLISHED, false)?
     .visit_field::<bool>("blocked", Self::VT_BLOCKED, false)?
     .finish();
    Ok(())
  }
}
pub struct GalleryArgs<'a> {
    pub gallery_id: i32,
    pub title: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub date: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub files: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<File<'a>>>>>,
    pub languages: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Language<'a>>>>>,
    pub scene_indexes: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, i32>>>,
    pub type_: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub id: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub related: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<&'a str>>>>,
    pub japanese_title: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub language: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub language_localname: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub language_url: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub video: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub videofilename: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub artists: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Artist<'a>>>>>,
    pub groups: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Group<'a>>>>>,
    pub characters: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Character<'a>>>>>,
    pub parodies: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Parody<'a>>>>>,
    pub tags: Option<::flatbuffers::WIPOffset<::flatbuffers::Vector<'a, ::flatbuffers::ForwardsUOffset<Tag<'a>>>>>,
    pub gallery_url: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub date_published: Option<::flatbuffers::WIPOffset<&'a str>>,
    pub blocked: bool,
}
impl<'a> Default for GalleryArgs<'a> {
  #[inline]
  fn default() -> Self {
    GalleryArgs {
      gallery_id: 0,
      title: None, // required field
      date: None, // required field
      files: None,
      languages: None,
      scene_indexes: None,
      type_: None, // required field
      id: None, // required field
      related: None,
      japanese_title: None,
      language: None,
      language_localname: None,
      language_url: None,
      video: None,
      videofilename: None,
      artists: None,
      groups: None,
      characters: None,
      parodies: None,
      tags: None,
      gallery_url: None,
      date_published: None,
      blocked: false,
    }
  }
}

pub struct GalleryBuilder<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> {
  fbb_: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
  start_: ::flatbuffers::WIPOffset<::flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: ::flatbuffers::Allocator + 'a> GalleryBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_gallery_id(&mut self, gallery_id: i32) {
    self.fbb_.push_slot::<i32>(Gallery::VT_GALLERY_ID, gallery_id, 0);
  }
  #[inline]
  pub fn add_title(&mut self, title: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_TITLE, title);
  }
  #[inline]
  pub fn add_date(&mut self, date: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_DATE, date);
  }
  #[inline]
  pub fn add_files(&mut self, files: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<File<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_FILES, files);
  }
  #[inline]
  pub fn add_languages(&mut self, languages: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Language<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_LANGUAGES, languages);
  }
  #[inline]
  pub fn add_scene_indexes(&mut self, scene_indexes: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , i32>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_SCENE_INDEXES, scene_indexes);
  }
  #[inline]
  pub fn add_type_(&mut self, type_: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_TYPE_, type_);
  }
  #[inline]
  pub fn add_id(&mut self, id: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_ID, id);
  }
  #[inline]
  pub fn add_related(&mut self, related: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<&'b  str>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_RELATED, related);
  }
  #[inline]
  pub fn add_japanese_title(&mut self, japanese_title: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_JAPANESE_TITLE, japanese_title);
  }
  #[inline]
  pub fn add_language(&mut self, language: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_LANGUAGE, language);
  }
  #[inline]
  pub fn add_language_localname(&mut self, language_localname: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_LANGUAGE_LOCALNAME, language_localname);
  }
  #[inline]
  pub fn add_language_url(&mut self, language_url: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_LANGUAGE_URL, language_url);
  }
  #[inline]
  pub fn add_video(&mut self, video: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_VIDEO, video);
  }
  #[inline]
  pub fn add_videofilename(&mut self, videofilename: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_VIDEOFILENAME, videofilename);
  }
  #[inline]
  pub fn add_artists(&mut self, artists: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Artist<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_ARTISTS, artists);
  }
  #[inline]
  pub fn add_groups(&mut self, groups: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Group<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_GROUPS, groups);
  }
  #[inline]
  pub fn add_characters(&mut self, characters: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Character<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_CHARACTERS, characters);
  }
  #[inline]
  pub fn add_parodies(&mut self, parodies: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Parody<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_PARODIES, parodies);
  }
  #[inline]
  pub fn add_tags(&mut self, tags: ::flatbuffers::WIPOffset<::flatbuffers::Vector<'b , ::flatbuffers::ForwardsUOffset<Tag<'b >>>>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_TAGS, tags);
  }
  #[inline]
  pub fn add_gallery_url(&mut self, gallery_url: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_GALLERY_URL, gallery_url);
  }
  #[inline]
  pub fn add_date_published(&mut self, date_published: ::flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<::flatbuffers::WIPOffset<_>>(Gallery::VT_DATE_PUBLISHED, date_published);
  }
  #[inline]
  pub fn add_blocked(&mut self, blocked: bool) {
    self.fbb_.push_slot::<bool>(Gallery::VT_BLOCKED, blocked, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>) -> GalleryBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    GalleryBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> ::flatbuffers::WIPOffset<Gallery<'a>> {
    let o = self.fbb_.end_table(self.start_);
    self.fbb_.required(o, Gallery::VT_TITLE,"title");
    self.fbb_.required(o, Gallery::VT_DATE,"date");
    self.fbb_.required(o, Gallery::VT_TYPE_,"type_");
    self.fbb_.required(o, Gallery::VT_ID,"id");
    ::flatbuffers::WIPOffset::new(o.value())
  }
}

impl ::core::fmt::Debug for Gallery<'_> {
  fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
    let mut ds = f.debug_struct("Gallery");
      ds.field("gallery_id", &self.gallery_id());
      ds.field("title", &self.title());
      ds.field("date", &self.date());
      ds.field("files", &self.files());
      ds.field("languages", &self.languages());
      ds.field("scene_indexes", &self.scene_indexes());
      ds.field("type_", &self.type_());
      ds.field("id", &self.id());
      ds.field("related", &self.related());
      ds.field("japanese_title", &self.japanese_title());
      ds.field("language", &self.language());
      ds.field("language_localname", &self.language_localname());
      ds.field("language_url", &self.language_url());
      ds.field("video", &self.video());
      ds.field("videofilename", &self.videofilename());
      ds.field("artists", &self.artists());
      ds.field("groups", &self.groups());
      ds.field("characters", &self.characters());
      ds.field("parodies", &self.parodies());
      ds.field("tags", &self.tags());
      ds.field("gallery_url", &self.gallery_url());
      ds.field("date_published", &self.date_published());
      ds.field("blocked", &self.blocked());
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Gallery`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gallery_unchecked`.
pub fn root_as_gallery(buf: &[u8]) -> Result<Gallery<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root::<Gallery>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Gallery` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_gallery_unchecked`.
pub fn size_prefixed_root_as_gallery(buf: &[u8]) -> Result<Gallery<'_>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root::<Gallery>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Gallery` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gallery_unchecked`.
pub fn root_as_gallery_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Gallery<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::root_with_opts::<Gallery<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Gallery` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_gallery_unchecked`.
pub fn size_prefixed_root_as_gallery_with_opts<'b, 'o>(
  opts: &'o ::flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Gallery<'b>, ::flatbuffers::InvalidFlatbuffer> {
  ::flatbuffers::size_prefixed_root_with_opts::<Gallery<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Gallery and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Gallery`.
pub unsafe fn root_as_gallery_unchecked(buf: &[u8]) -> Gallery<'_> {
  unsafe { ::flatbuffers::root_unchecked::<Gallery>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Gallery and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Gallery`.
pub unsafe fn size_prefixed_root_as_gallery_unchecked(buf: &[u8]) -> Gallery<'_> {
  unsafe { ::flatbuffers::size_prefixed_root_unchecked::<Gallery>(buf) }
}
#[inline]
pub fn finish_gallery_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(
    fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>,
    root: ::flatbuffers::WIPOffset<Gallery<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_gallery_buffer<'a, 'b, A: ::flatbuffers::Allocator + 'a>(fbb: &'b mut ::flatbuffers::FlatBufferBuilder<'a, A>, root: ::flatbuffers::WIPOffset<Gallery<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod Schema
}  // pub mod MyApp

